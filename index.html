<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>WP-FASE - </title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


<section class="title" data-background="transparent">
	<h1>WP-FASE</h1>
	<h5>Documentation for Hookers</h5>
	<h6><a href="https://github.com/crowdfavorite/wp-fase">GitHub.com/CrowdFavorite/WP-Fase</a></h6>
</section>


<section data-markdown>
	# The Problem

	- WordPress Hooks (filters and actions) are extremely powerful
	- They are also complex with “lots of moving parts”. 

	Diagnosing problems can require a lot of manual work. Having a road map of these calls 
	for a particular code base would be handy:

	- `add_action`
	- `add_filter`
	- `apply_filters`
	- `do_action`
	- `do_action_ref_array` 

</section>

<section data-markdown>
	# The State of the Doc

	We looked high and low for a utility that did this, but none existed.

	- There is no easy or automatic way to capture the various hooks and calls to them in WordPress code. 
	- Documentation for plugins and themes can be weak or non-existent.
	- Documentation tools like _phpDoucmentor_  don’t go “inside” functions where most of the hooks and related calls are located
	
	## Conclusion

	We needed to write our own utility to generate this information.

</section>


<section data-markdown>
	# The solution: WP-FASE

	What is it?
	
	- **W**ord**P**ress 
	- **F**ilter and 
	- **A**ction 
	- **S**yntax 
	- **E**xtractor

	## And it does?

	WP-FASE traverses an arbitrary given folder to find all instances of WordPress hooks. It has HTML, JSON, or plain text output. 
</section>

<section data-markdown>
	# Invoking WP-FASE

	`cd` to the folder where WP-FASE is checked out.  
	`php extract.php [options]`

	## Options

	Some options, such as the directory, are required. The following options are available:

	```json
	-d  path to the directory to traverse. REQUIRED

	-r  text to remove from file paths in output. Defaults to value given in '-d' 
	    if not specified.

	-f  File Types, comma separated (no spaces). Defaults to 'php,inc'.

	-t  Output Type. HTML, JSON or text. Defaults to HTML. Invalid values go to 
	    default.
	```

</section>


<section data-markdown>
	# What does it do?

	The overall approach is to analyze code and extract only the parts we needed.

	- This is much easier said than done. 
	- Code can be pretty complicated. 

	## RegEx to the Rescue?

	The initial appraoch was starting to look like we were going to be in Regular Expression hell for the foreseeable future. RegEx is complicated enough
	without analyzing lots of code, trying to figure out how to get parameters, docblocks, and other goodies related to the hook calls.

</section>


<section class="transparent">
	<section data-markdown>
		# NO! Tokenizer to the Rescue

		After a few minutes of RegEx despair we researched alternate methods and found the **PHP Tokenizer**.

		- Built-in extension since PHP 4.3.0.</p>
		- **http://www.php.net/manual/en/function.token-get-all.php**

		## So what does Tokenizing do?

		Tokenizing splits any arbitrary PHP source into an array of tokens. These PHP tokens are valuable pieces of information and eliminate the need for regular expressions and lexical gymnastics.

	</section>


	<section data-markdown data-background="#006600" style="background: transparent;">
		# _Coder Zone:_  
		# What’s in a token?

		The tokens returned by PHP's tokenizer contain either a single character (`;`, `.`, `&gt;`, `!`, etc.) or a three-element array containing:

		- **[0]** Token index (PHP language part) 
		- **[1]** String content of the original token 
		- **[2]** Line number (as of PHP 5.2.2)
		
		## Constants are good 

		Is is beneficial to define constants for the various token pieces (`TOKEN_INDEX`, `TOKEN_STRING`, `TOKEN_LINE_NUMBER`) in order to avoid magic numbers.
	</section>

	<section data-markdown data-background="#006600" style="background: transparent;">
		# _Coder Zone:_ 
		# More token information

		The token index is a numeric value that reveals the part of the PHP language that was found. The `token_name($value)` function returns the symbolic name (`T_*`) for the given numeric value. 

		Token values vary from version to version of PHP. This means that:

		- The numeric value of a token is unreliable. 
		- Code should reference the `T_*` constants instead.

		List of tokens: **http://www.php.net/manual/en/tokens.php**
	</section>

	<section data-markdown data-background="#006600" style="background: transparent;">
		# _Coder Zone:_ 
		# Token examples

		Examples of raw tokens.

		```
		[0] =&gt; 368 (T_OPEN_TAG)
		[1] =&gt; &lt;?php
		[2] =&gt; 1

		[0] =&gt; 367 (T_DOC_COMMENT)
		[1] =&gt; /**
		 * Front to the WordPress application. This file doesn&#39;t do anything, 
		 * but loads wp-blog-header.php which does and tells WordPress to load 
		 * the theme.
		 *
		 * @package WordPress
		 */
		[2] =&gt; 2

		[0] =&gt; 371 (T_WHITESPACE)
		[1] =&gt; &nbsp;
		[2] =&gt; 7


		[0] =&gt; 367 (T_DOC_COMMENT)
		[1] =&gt; /**
		 * Tells WordPress to load the WordPress theme and output it.
		 *
		 * @var bool
		 */
		[2] =&gt; 9

		[0] =&gt; 371 (T_WHITESPACE)
		[1] =&gt; &nbsp;
		[2] =&gt; 13

		[0] =&gt; 307 (T_STRING)
		[1] =&gt; define
		[2] =&gt; 14

		[0] =&gt; 315 (T_CONSTANT_ENCAPSED_STRING)
		[1] =&gt; &#39;WP_USE_THEMES&#39;
		[2] =&gt; 14
		```
	</section>

</section>

<section  class="transparent">
	<section>
		<h1>Parsing the Hooks</h1>

		<p>Hook functions: <code>add_action</code>, <code>add_filter</code>, <code>apply_filters</code>, <code>do_action</code>, <code>do_action_ref_array</code>
		<ul>
		<li>Each one has a slightly different syntax, so they get their own processors </li>
		<li>Processors behave in more or less the same way:
			<ul>
			<li>Add found information into two arrays</li>
			<li>Array 1 indexed by the hook name </li>
			<li>Array 2 indexed by filename and line number</li>
		</ul>
		</li>
		<li>There is also a generic processor the hook processors call to get call parameters and docblocks.</li>
		</ul>
	</section>


	<section data-markdown data-background="#006600" style="background: transparent;">
	# _Coder Zone:_  
	# Example Array Data

	```
	[wp_head] =&gt; Array
	    [0] =&gt; Array
	      [token] =&gt; Array
	        [0] =&gt; 307
	        [1] =&gt; add_action
	        [2] =&gt; 47
	      [file] =&gt; Array
	        [dir] =&gt; ../wp
	        [file] =&gt; wp-activate.php
	        [fullpath] =&gt; ../wp/wp-activate.php
	        [friendly_name] =&gt; wp-activate.php

	      [hook] =&gt; wp_head
	      [function_to_add] =&gt; &#39;do_activate_header&#39;
	      [priority] =&gt; 10 (default)
	      [arguments] =&gt; 1 (default)
	    [1] =&gt; Array
	      [token] =&gt; Array
	        [0] =&gt; 307
	        [1] =&gt; add_action
	        [2] =&gt; 65
	      [file] =&gt; Array
	        [dir] =&gt; ../wp
	        [file] =&gt; wp-activate.php
	        [fullpath] =&gt; ../wp/wp-activate.php
	        [friendly_name] =&gt; wp-activate.php
	      [hook] =&gt; wp_head
	      [function_to_add] =&gt; &#39;wpmu_activate_stylesheet&#39;
	      [priority] =&gt; 10 (default)
	      [arguments] =&gt; 1 (default)
	```
	
	An example of the raw array data for `wp_head`.

	</section>
</section>


<section data-markdown>
	# Post-processing

	- The data arrays (hooks, filenames) have been gathered
	- The output is gathered, formatted and sent out. 

	The data is in a standard format, so the processors simply iterate the arrays and assemble the correct information.
	
	There are output processors for <tt>HTML</tt>, <tt>JSON</tt>, and plain text. Other output formats are easy to generate...
</section>

<section data-markdown>
	# WP-FASE's Future

	There are a few TODO items:

	- Better HTML output (probably with frames like _phpDocumentor_)
	- More flexible themes / styling
	- Additional output processors
	- Compile into a single PHAR file for easy installation

	## Can we get some uptake here?

	- Please start using WP-FASE
	- Feedback and contributions would be greatly appreciated

</section>

<section data-markdown>
	# References

	## Public GitHub repo
	- __https://github.com/crowdfavorite/wp-fase__

	## This presentation deck
	- __http://mospaw.com/wp-fase-reveal__

</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				width: 1200,
    			height: 900,


				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
